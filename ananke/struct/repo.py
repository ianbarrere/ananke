#!/usr/bin/env python3
import datetime
from typing import Any, Optional, Literal, List, Dict, Union, Iterable
from pathlib import Path, PosixPath


def get_branch_name() -> str:
    """
    Function to autogenerate a branch name
    """
    now = datetime.datetime.now()
    midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
    seconds = (now - midnight).seconds
    return f"feature/auto-{datetime.datetime.now().strftime('%Y%m%d')}{seconds}"


class LocalRepo:
    """
    Class for interacting with local git repo.

    There is probably a better way to handle both GitLabRepo and LocalRepo using
    inheritance since many of the methods are at least superficially similar, but I have
    not been able to figure out a good way, so we have two unrelated classes for now.
    """

    from git import Repo  # type: ignore
    import os

    def __init__(self, repo_dir: str, branch: Union[bool, str] = True):
        if not self.os.path.exists(repo_dir):
            raise ValueError(f"The provided repo directory {repo_dir} does not exist")
        self.repo_dir = repo_dir
        self.repo = self.Repo(repo_dir)
        self.create_branch(branch)

    def create_branch(self, branch_name: Union[bool, str]) -> Optional[str]:
        """
        Conditionally create a branch based on main. Accepts either boolean or string,
        if False no branch is created, if True or string branch is created with either
        autogenerated name or provided string.
        """
        if branch_name:
            if isinstance(branch_name, bool):
                name = str(self.repo.create_head(get_branch_name()))
            else:
                name = str(self.repo.create_head(branch_name))
        else:
            name = None
        self.branch_name = name

    def get_file(self, path: str, create: bool = False) -> Union[Any, bool]:
        """
        Get raw content of a file
        """
        try:
            with open(f"{self.repo_dir}/{path}", "rb") as file:
                return file.read()
        except FileNotFoundError as err:
            if create:
                return False
            raise FileNotFoundError(err)

    def get_branches(self) -> Any:
        """
        List branches in the project
        """
        branches: Iterable = self.repo.branches  # type: ignore
        return [branch.name for branch in branches]

    def diff_branches(self, from_branch: str, to_branch: str) -> Any:
        """
        Diff two branches, package inside dict so as to be interchangeable with API
        format
        """
        dest = self.repo.commit(to_branch)
        source = self.repo.commit(from_branch)
        return {"diffs": source.diff(dest)}

    def list_objects(self) -> List[PosixPath]:
        """
        Lists the contents of a repo.
        """
        config_dir = Path(self.repo_dir)
        return [Path(path).relative_to(config_dir) for path in config_dir.rglob("*")]

    def update_file(
        self,
        path: str,
        content: str,
        author_email: Optional[str] = None,
        author_name: Optional[str] = None,
        commit_message: str = "Automated commit",
    ) -> None:
        """
        Update content of a given file
        """
        if not self.branch_name:
            raise ValueError("Cannot commit without creating branch first")
        self.repo.git.checkout(self.branch_name)
        with open(f"{self.repo_dir}/{path}", "w") as file:
            file.write(content)
        self.repo.index.add([path])
        if any([author_email, author_name]):
            self.repo.config_writer().set_value("user", "name", author_name).release()
            self.repo.config_writer().set_value("user", "email", author_email).release()
        self.repo.index.commit(commit_message)

    def bulk_commit(self, commit_message: str, actions: List[Any]) -> None:
        """
        Commit multiple files, local abstraction for GitLab functionality.
        """
        if not self.branch_name:
            raise ValueError("Cannot commit without branch")

        self.repo.git.checkout(self.branch_name)
        for action in actions:
            with open(f"{self.repo_dir}/{action['file_path']}", "w") as file:
                file.write(action["content"])
            self.repo.index.add([action["file_path"] for action in actions])
        if any([actions[0]["author_email"], actions[0]["author_name"]]):
            self.repo.config_writer().set_value(
                "user", "name", actions[0]["author_name"]
            ).release()
            self.repo.config_writer().set_value(
                "user", "email", actions[0]["author_email"]
            ).release()
        self.repo.index.commit(commit_message)

    def create_pr(self, title: str, description: Optional[str] = None) -> str:
        """
        Returns not supported message
        """
        return (
            "Create PR functionality not supported for local repo. Push your branch "
            f"{self.branch_name} to remote and create PR manually"
        )

    def get_prs(self) -> str:
        """
        Returns not supported message
        """
        return "Get PR functionality not supported for local repo"


class GitLabRepo:
    """
    Class for interacting with GitLab Repo API
    """

    import requests  # type: ignore

    def __init__(self, project_id: str, token: str, branch: Union[bool, str] = True):
        self.project_id = project_id
        self.token = token
        self.create_branch(branch)

    def _api(
        self,
        method: Literal["get", "put", "post", "delete"],
        suffix: str,
        body: Optional[Any] = None,
        params: Optional[Dict[str, Optional[str]]] = None,
        raise_on_error: bool = True,
    ) -> requests.Response:
        """
        Generic API component for GitLab
        """
        headers = {"PRIVATE-TOKEN": self.token}
        url_base = f"https://gitlab.com/api/v4/projects/{self.project_id}/"
        params = params
        response = getattr(self.requests, method)(
            url=f"{url_base}/{suffix}", headers=headers, json=body, params=params
        )
        if raise_on_error:
            response.raise_for_status()
        return response

    def create_branch(self, branch_name: Union[bool, str]) -> Optional[str]:
        """
        Conditionally create a branch based on main. Accepts either boolean or string,
        if False no branch is created, if True or string branch is created with either
        autogenerated name or provided string.
        """

        def _create_branch_api(branch_name: str):
            response = self._api(
                method="post",
                suffix="repository/branches?branch="
                f"{branch_name.replace('/', '%2F')}&ref=main",
                raise_on_error=False,
            )
            if response.status_code == 201 or (
                response.status_code == 400
                and response.json()["message"] == "Branch already exists"
            ):
                return branch_name

        if branch_name:
            if isinstance(branch_name, bool):
                name = _create_branch_api(get_branch_name())
            else:
                name = _create_branch_api(branch_name)
        else:
            name = None
        self.branch_name = name

    def delete_branch(self) -> None:
        """
        Delete branch
        """
        if self.branch_name:
            self._api(
                method="delete",
                suffix=f"repository/branches/{self.branch_name.replace('/', '%2F')}",
            )

    def get_branches(self) -> Any:
        """
        List branches in the project
        """
        return self._api(method="get", suffix=f"repository/branches").json()

    def get_file(
        self, path: str, branch: Optional[str] = None, create: bool = False
    ) -> Union[Any, bool]:
        """
        Get raw content of a file, return False if not found
        """
        path = path.replace("/", "%2F")
        branch_name = "main"
        if self.branch_name:
            branch_name = self.branch_name
        if branch:
            branch_name = branch
        branch_name = branch_name.replace("/", "%2F")
        response = self._api(
            method="get",
            suffix=f"repository/files/{path}/raw?ref={branch_name}",
            raise_on_error=not create,
        )
        if response.content.decode() == '{"message":"404 File Not Found"}':
            return False
        return response.content

    def list_objects(self) -> List[PosixPath]:
        """
        Lists the contents of a repo.
        """
        params = {"recursive": True, "per_page": 10000}
        if self.branch_name:
            params["ref"] = self.branch_name
        response = self._api(
            method="get",
            params=params,
            suffix="repository/tree",
        )
        objects = [Path(object["path"]) for object in response.json()]
        return objects

    def update_file(
        self,
        path: str,
        content: str,
        author_email: str = "sre@doubleverify.com",
        author_name: str = "SRE",
        commit_message: str = "Automated commit",
    ) -> None:
        """
        Update content of a given file
        """
        if not self.branch_name:
            raise ValueError("Cannot commit without creating branch first")
        body = {
            "branch": self.branch_name,
            "author_email": author_email,
            "author_name": author_name,
            "content": content,
            "commit_message": commit_message,
        }
        path = path.replace("/", "%2F")
        self._api(method="put", suffix=f"repository/files/{path}", body=body)

    def bulk_commit(self, commit_message: str, actions: List[Any]) -> None:
        """
        Commit multiple files using GitLab commit API
        """
        if not self.branch_name:
            raise ValueError("Cannot commit without branch")

        body = {
            "branch": self.branch_name,
            "commit_message": commit_message,
            "actions": actions,
        }
        self._api(
            method="post",
            suffix=f"repository/commits",
            body=body,
            raise_on_error=False,
        )

    def get_prs(self) -> Any:
        """
        Return opened PRs
        """
        return self._api(
            method="get", suffix="merge_requests", params={"state": "opened"}
        ).json()

    def create_pr(self, title: str, description: Optional[str] = None) -> str:
        """
        Create pull request for main from branch and return URL. Checks for branch diff
        before proceeding and deletes unchanged branches to prevent pileups from
        automated change processes.
        """
        if not self.branch_name:
            return "A branch has not been created, cannot create PR"
        diff_response = self.diff_branches(
            from_branch="main", to_branch=self.branch_name
        )
        if diff_response["diffs"] == []:
            self.delete_branch()
            return "No changes, deleting branch"
        body = {
            "title": title,
            "source_branch": self.branch_name,
            "target_branch": "main",
        }
        if description:
            body["description"] = description
        response = self._api(method="post", suffix="merge_requests", body=body)
        self.pr_iid = response.json()["iid"]
        return response.json()["web_url"]

    def diff_branches(self, from_branch: str, to_branch: str) -> Any:
        """
        Diff two branches
        """
        return self._api(
            method="get",
            suffix="repository/compare",
            params={"from": from_branch, "to": to_branch},
        ).json()

    def delete_pr(self) -> None:
        """
        Delete pull request
        """
        self._api(method="delete", suffix=f"merge_requests/{self.pr_iid}")


def get_repo(
    target: str, token: Optional[str] = None, branch: Union[bool, str] = True
) -> Union[LocalRepo, GitLabRepo]:
    """
    A unified interface for getting a repo back. It returns a LocalRepo if the target
    is a local path and it returns a GitLabRepo if given a numerical target and token
    """
    if target.isnumeric() and not token:
        raise ValueError("If target is a GitLab project ID a token must be supplied")
    if target.isnumeric() and token:
        return GitLabRepo(target, token, branch)
    return LocalRepo(target, branch)
