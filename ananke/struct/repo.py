#!/usr/bin/env python3
import datetime
from typing import Any, Optional, Literal, List, Dict, Union, Iterable
from pathlib import Path, PosixPath


def get_branch_name() -> str:
    """
    Function to autogenerate a branch name
    """
    now = datetime.datetime.now()
    midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
    seconds = (now - midnight).seconds
    return f"feature/auto-{datetime.datetime.now().strftime('%Y%m%d')}{seconds}"


class LocalRepo:
    """
    Class for interacting with local git repo.

    There is probably a better way to handle both GitLabRepo and LocalRepo using
    inheritance since many of the methods are at least superficially similar, but I have
    not been able to figure out a good way, so we have two unrelated classes for now.
    """

    from git import Repo  # type: ignore
    import os

    def __init__(self, repo_dir: str, branch: Union[bool, str] = True):
        if not self.os.path.exists(repo_dir):
            raise ValueError(f"The provided repo directory {repo_dir} does not exist")
        self.repo_dir = repo_dir
        self.repo = self.Repo(repo_dir)
        self.branch_name = self.create_branch(branch)

    def create_branch(self, branch_name: Union[bool, str]) -> Optional[str]:
        """
        Conditionally create a branch based on main. Accepts either boolean or string,
        if False no branch is created, if True or string branch is created with either
        autogenerated name or provided string.
        """
        if branch_name:
            if isinstance(branch_name, bool):
                return str(self.repo.create_head(get_branch_name()))
            return str(self.repo.create_head(branch_name))
        return None

    def get_file(self, path: str) -> Any:
        """
        Get raw content of a file
        """
        with open(f"{self.repo_dir}/{path}", "rb") as file:
            return file.read()

    def get_branches(self) -> Any:
        """
        List branches in the project
        """
        branches: Iterable = self.repo.branches  # type: ignore
        return [branch.name for branch in branches]

    def diff_branches(self, from_branch: str, to_branch: str) -> Any:
        """
        Diff two branches, package inside dict so as to be interchangeable with API
        format
        """
        dest = self.repo.commit(to_branch)
        source = self.repo.commit(from_branch)
        return {"diffs": source.diff(dest)}

    def list_objects(self) -> List[str]:
        """
        Lists the contents of a repo.
        """
        return [path for path in Path(f"{self.repo_dir}/").rglob("*")]

    def update_file(
        self,
        path: str,
        content: str,
        author_email: Optional[str] = None,
        author_name: Optional[str] = None,
        commit_message: str = "Automated commit",
    ) -> None:
        """
        Update content of a given file
        """
        if not self.branch_name:
            raise ValueError("Cannot commit without creating branch first")
        self.repo.git.checkout(self.branch_name)
        with open(f"{self.repo_dir}/{path}", "w") as file:
            file.write(content)
        self.repo.index.add([path])
        if any([author_email, author_name]):
            self.repo.config_writer().set_value("user", "name", author_name).release()
            self.repo.config_writer().set_value("user", "email", author_email).release()
        self.repo.index.commit(commit_message)

    def create_pr(self, title: str) -> str:
        """
        Returns not supported message
        """
        return (
            "Create PR functionality not supported for local repo. Push your branch "
            f"{self.branch_name} to remote and create PR manually"
        )

    def get_prs(self) -> str:
        """
        Returns not supported message
        """
        return "Get PR functionality not supported for local repo"


class GitLabRepo:
    """
    Class for interacting with GitLab Repo API
    """

    import requests  # type: ignore

    def __init__(self, project_id: str, token: str, branch: Union[bool, str] = True):
        self.project_id = project_id
        self.token = token
        self.branch_name = self.create_branch(branch)

    def _api(
        self,
        method: Literal["get", "put", "post", "delete"],
        suffix: str,
        body: Optional[Any] = None,
        params: Optional[Dict[str, Optional[str]]] = None,
    ) -> requests.Response:
        """
        Generic API component for GitLab
        """
        headers = {"PRIVATE-TOKEN": self.token}
        url_base = f"https://gitlab.com/api/v4/projects/{self.project_id}/"
        params = params
        response = getattr(self.requests, method)(
            url=f"{url_base}/{suffix}", headers=headers, json=body, params=params
        )
        response.raise_for_status()
        return response

    def create_branch(self, branch_name: Union[bool, str]) -> Optional[str]:
        """
        Conditionally create a branch based on main. Accepts either boolean or string,
        if False no branch is created, if True or string branch is created with either
        autogenerated name or provided string.
        """

        def _create_branch_api(branch_name: str):
            self._api(
                method="post",
                suffix="repository/branches?branch="
                f"{branch_name.replace('/', '%2F')}&ref=main",
            )
            return branch_name

        if branch_name:
            if isinstance(branch_name, bool):
                return _create_branch_api(get_branch_name())
            return _create_branch_api(branch_name)
        return None

    def delete_branch(self) -> None:
        """
        Delete branch
        """
        if self.branch_name:
            self._api(
                method="delete",
                suffix=f"repository/branches/{self.branch_name.replace('/', '%2F')}",
            )

    def get_branches(self) -> Any:
        """
        List branches in the project
        """
        return self._api(method="get", suffix=f"repository/branches").json()

    def get_file(self, path: str, branch: Optional[str] = None) -> Any:
        """
        Get raw content of a file
        """
        path = path.replace("/", "%2F")
        branch_name = "main"
        if self.branch_name:
            branch_name = self.branch_name
        if branch:
            branch_name = branch
        branch_name = branch_name.replace("/", "%2F")
        response = self._api(
            method="get", suffix=f"repository/files/{path}/raw?ref={branch_name}"
        )
        return response.content

    def list_objects(self) -> List[PosixPath]:
        """
        Lists the contents of a repo.
        """
        response = self._api(
            method="get",
            params={"recursive": True, "per_page": 100},
            suffix="repository/tree",
        )
        objects = [Path(object["path"]) for object in response.json()]
        page = 1
        while page < int(response.headers["x-total-pages"]):
            page += 1
            response = self._api(
                method="get",
                params={"recursive": True, "per_page": 100, "page": page},
                suffix="repository/tree",
            )
            objects.extend([Path(object["path"]) for object in response.json()])
        return objects

    def update_file(
        self,
        path: str,
        content: str,
        author_email: str = "sre@doubleverify.com",
        author_name: str = "SRE",
        commit_message: str = "Automated commit",
    ) -> None:
        """
        Update content of a given file
        """
        if not self.branch_name:
            raise ValueError("Cannot commit without creating branch first")
        body = {
            "branch": self.branch_name,
            "author_email": author_email,
            "author_name": author_name,
            "content": content,
            "commit_message": commit_message,
        }
        path = path.replace("/", "%2F")
        self._api(method="put", suffix=f"repository/files/{path}", body=body)

    def get_prs(self) -> Any:
        """
        Return opened PRs
        """
        return self._api(
            method="get", suffix="merge_requests", params={"state": "opened"}
        ).json()

    def create_pr(self, title: str) -> str:
        """
        Create pull request for main from branch and return URL. Checks for branch diff
        before proceeding and deletes unchanged branches to prevent pileups from
        automated change processes.
        """
        if not self.branch_name:
            return "A branch has not been created, cannot create PR"
        diff_response = self.diff_branches(
            from_branch="main", to_branch=self.branch_name
        )
        if diff_response["diffs"] == []:
            self.delete_branch()
            return "No changes, deleting branch"
        body = {
            "title": title,
            "source_branch": self.branch_name,
            "target_branch": "main",
        }
        response = self._api(method="post", suffix="merge_requests", body=body)
        self.pr_iid = response.json()["iid"]
        return response.json()["web_url"]

    def diff_branches(self, from_branch: str, to_branch: str) -> Any:
        """
        Diff two branches
        """
        return self._api(
            method="get",
            suffix="repository/compare",
            params={"from": from_branch, "to": to_branch},
        ).json()

    def delete_pr(self) -> None:
        """
        Delete pull request
        """
        self._api(method="delete", suffix=f"merge_requests/{self.pr_iid}")


def get_repo(
    target: str, token: Optional[str] = None, branch: Union[bool, str] = True
) -> Union[LocalRepo, GitLabRepo]:
    """
    A unified interface for getting a repo back. It returns a LocalRepo if the target
    is a local path and it returns a GitLabRepo if given a numerical target and token
    """
    if target.isnumeric() and not token:
        raise ValueError("If target is a GitLab project ID a token must be supplied")
    if target.isnumeric() and token:
        return GitLabRepo(target, token, branch)
    return LocalRepo(target, branch)
